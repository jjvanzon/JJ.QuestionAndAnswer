<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JJ.Framework.Collections</name>
    </assembly>
    <members>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Add``1(System.Collections.Generic.IList{``0},``0[])">
            <summary>
            Add multiple items to a collection by means of a comma separated argument list, e.g. myCollection.Add(1, 5,
            12);
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Add``1(System.Collections.Generic.Stack{``0},``0)">
            <summary>
            For some polymorphism between Lists, Stacks and Queues, there are these Add and Remove extension methods,
            in place of Push, Pop, Enqueue and Dequeue.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Add``1(System.Collections.Generic.Queue{``0},``0)">
            <summary>
            For some polymorphism between Lists, Stacks and Queues, there are these Add and Remove extension methods,
            in place of Push, Pop, Enqueue and Dequeue.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.AddRange``1(System.Collections.Generic.HashSet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary> AddRange is a member of List&lt;T&gt;. Here is an overload for HashSet&lt;T&gt;. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.AddRange``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary> AddRange is a member of List&lt;T&gt;. Here is an overload for IEnumerable&lt;T&gt;. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.AsArray``1(``0)">
            <summary>
            Converts a single item to an array. Example: int[] myInts = 3.AsArray();
            (The names 'ToArray' and 'ToList' conflicted with other overloads.)
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.AsEnumerable``1(``0)">
            <summary>
            Converts a single item to an enumerable.
            Example: IEnumerable&lt;int&gt; myEnumerable = 3.AsEnumerable();
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.AsList``1(``0)">
            <summary>
            Converts a single item to a list. Example: List&lt;int&gt; myInts = 3.AsList();
            (The names 'ToArray' and 'ToList' conflicted with other overloads.)
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Concat``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary> Overload of Concat that takes a single item, e.g. myCollection.Concat(myItem); </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Concat``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary> Overload of Concat that takes a comma separated argument list, e.g. myCollection.Concat(4, 7, 12); </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Concat``1(``0,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Overload of Concat that starts with a single item and then adds a collection to it e.g.
            myItem.Concat(myCollection);
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.CrossJoin``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Returns all possible pairs of items combining one from collection1 with one from collection2. The pairs are
            returned as tuples.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.CrossJoin``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})">
            <summary>
            Returns all possible combinations of items, combining one from collection1 with one from collection2. The
            resultant item is produced by the resultSelector.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.CrossJoin``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}},System.Func{System.Collections.Generic.IEnumerable{``0},``1})">
            <summary>
            Returns all possible combinations of items, combining one from the first collection with one from second collection and
            one from the third collection etc.
            The resultant item is produced by the resultSelector, which takes an enumerable of items as input.
            This overload will only work if all item types are the same but you can use enumerables of object to use items of
            multiple types.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Distinct``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Distinct that takes a key selector that determines what makes an item unique, e.g. myItems.Distinct(x => x.LastName);
            For multi-part as keys, use `myItems.Distinct(x => new { x.FirstName, x.LastName });`
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.DistinctMany``1(System.Collections.Generic.IEnumerable{``0[]})">
            <summary>
            Returns distinct arrays. So checks the equality of all items in the arrays and returns the unique arrays.
            (Actually, not only arrays, any enumerable.) E.g. severalArrays.Distinct();
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.DistinctMany``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Returns distinct arrays. So checks the equality of all items in the arrays and returns the unique arrays.
            (Actually, not only arrays, any enumerable.) E.g. severalArrays.Distinct();
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.DistinctMany``2(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns distinct arrays. So checks the equality of all items in the arrays and returns the unique arrays.
            (Actually, not only arrays, any enumerable.) E.g. severalArrays.Distinct();
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Except``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary> An overload of Except that takes just a single item, e.g. myCollection.Except(myItem); </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Except``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            An overload of Except that takes a predicate, e.g. myCollection.Except(x => string.Equals("Blah");
            (This is the same as a negated Where predicate, but if you are already thinking in terms of Except,
            this might express your intent clearer.)
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary>
            The original Except() method from .NET automatically does a distinct, which is something you do not always
            want, so there is one that gives you the choice.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.FirstWithClearException``1(System.Collections.Generic.IEnumerable{``0},System.Object)">
            <summary>
            A regular First() will give you an exception if there are no elements in the collection.
            But not a very clear exception, like 'Sequence contains no elements.'
            FirstWithClearException() will allow you to do a First,
            but get a clearer exception message e.g. 'Product with key { group = "Shoes" } not found.'
            Only really works if you filtered by something.
            </summary>
            <param name="keyIndicator">
            Not used for filtering, only used in the exception message.
            You can use an anonymous type e.g. new { id, cultureName } and it will translate that to something like { id = 1234,
            cultureName = nl-NL }.
            </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.FirstWithClearException``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            A regular First() will give you an exception if there are no elements in the collection.
            But not a very clear exception, like 'Sequence contains no elements.'
            FirstWithClearException() will allow you to do a First,
            but get a clearer exception message e.g. 'Product not found.'
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.FirstWithClearException``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Object)">
            <summary>
            A regular First() will give you an exception if there are no elements in the collection.
            But not a very clear exception, like 'Sequence contains no elements.'
            FirstWithClearException() will allow you to do a First,
            but get a clearer exception message e.g. 'Product with key { group = "Shoes" } not found.'
            Only really works if you filtered by something.
            </summary>
            <param name="keyIndicator">
            Not used for filtering, only used in the exception message.
            You can use an anonymous type e.g. new { id, cultureName } and it will translate that to something like { id = 1234,
            cultureName = nl-NL }.
            </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.FirstWithClearException``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            A regular First() will give you an exception if there are no elements in the collection.
            But not a very clear exception, like 'Sequence contains no elements.'
            FirstWithClearException() will allow you to do a First,
            but get a clearer exception message e.g. 'Product with key not found.'
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Not all collection types have the ForEach method. Here you have an overload for IEnumerable&lt;T&gt; so you
            can use it for more collection types.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.IndexOf``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the list index of the first item that matches the predicate.
            Does not check duplicates, because that would make it slower.
            (List&lt;T&gt; has FindIndex natively, but other collection types do not.)
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.IndexOf``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the list index of the first item that matches the predicate.
            E.g. int index = items.IndexOf(x => x.ID == 3);
            Does not check duplicates, because that would make it slower.
            (List&lt;T&gt; has FindIndex natively, but other collection types do not.)
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.IndexOf``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            IList&lt;T&gt; has an IndexOf method natively. This overload provides one for IEnumerable&lt;T&gt;,
            for both syntactic sugar and it prevents full materialization of the collection.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary>
            Would check whether the items in two collections are equal, optionally keeping the order in mind or not.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.MaxOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
            <summary> Same as Max(), but instead of crashing when zero items, returns default instead. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.MaxOrDefault``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary> Same as Max(), but instead of crashing when zero items, returns default instead. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.MinOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
            <summary> Same as Min(), but instead of crashing when zero items, returns default instead. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.MinOrDefault``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary> Same as Min(), but instead of crashing when zero items, returns default instead. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.PeekOrDefault``1(System.Collections.Generic.Stack{``0})">
            <summary> Same as Peek(), but instead of crashing when zero items, returns default instead. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.PopOrDefault``1(System.Collections.Generic.Stack{``0})">
            <summary> Same as Pop(), but instead of crashing when zero items, returns default instead. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.PeekOrDefault``1(System.Collections.Generic.Queue{``0})">
            <summary> Same as Peek(), but instead of crashing when zero items, returns default instead. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Product``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
            <summary>
            Works similar to Sum, but instead of adding up all the numbers, all the numbers are multiplied.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Works similar to Sum, but instead of adding up all the numbers, all the numbers are multiplied.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Product``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})">
            <summary>
            Works similar to Sum, but instead of adding up all the numbers, all the numbers are multiplied.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Works similar to Sum, but instead of adding up all the numbers, all the numbers are multiplied.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Product``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
            <summary>
            Works similar to Sum, but instead of adding up all the numbers, all the numbers are multiplied.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Works similar to Sum, but instead of adding up all the numbers, all the numbers are multiplied.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Product``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})">
            <summary>
            Works similar to Sum, but instead of adding up all the numbers, all the numbers are multiplied.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Works similar to Sum, but instead of adding up all the numbers, all the numbers are multiplied.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Product``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})">
            <summary>
            Works similar to Sum, but instead of adding up all the numbers, all the numbers are multiplied.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Decimal})">
            <summary>
            Works similar to Sum, but instead of adding up all the numbers, all the numbers are multiplied.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Remove``1(System.Collections.Generic.Stack{``0})">
            <summary>
            For some polymorphism between Lists, Stacks and Queues, there are these Add and Remove extension methods,
            in place of Push, Pop, Enqueue and Dequeue.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Remove``1(System.Collections.Generic.Queue{``0})">
            <summary>
            For some polymorphism between Lists, Stacks and Queues, there are these Add and Remove extension methods,
            in place of Push, Pop, Enqueue and Dequeue.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.RemoveFirst``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean})">
            <summary>
            Removes the first occurrence that matches the predicate.
            Throws an exception no item matches the predicate.
            Does not check duplicates, which makes it faster if you are sure only one item is in it.
            Example: myCollection.RemoveFirst(x => x.ID == 3);
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Repeat``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Repeats a collection a number of times and returns a new collection.
            E.g. new[] { 1, 2 }.Repeat(3);
            Returns a collection { 1, 2, 1, 2, 1, 2 }
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.SingleOrDefaultWithClearException``1(System.Collections.Generic.IEnumerable{``0},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            A regular SingleOrDefault() will give you an exception if there are multiple elements in the collection.
            But not a very clear exception, like 'The input sequence contains more than one element.'
            SingleOrDefaultWithClearException() will allow you to do a SingleOrDefault,
            but get a clearer exception message e.g. 'Product with key { productNumber = 1234 } not unique.'
            Only really works if you filtered by something.
            </summary>
            <param name="keyIndicator">
            Not used for filtering, only used in the exception message.
            You can use an anonymous type e.g. new { id, cultureName } and it will translate that to something like { id = 1234,
            cultureName = nl-NL }.
            </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.SingleOrDefaultWithClearException``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            A regular SingleOrDefault() will give you an exception if there are multiple elements in the collection.
            But not a very clear exception, like 'The input sequence contains more than one element.'
            SingleOrDefaultWithClearException() will allow you to do a SingleOrDefault,
            but get a clearer exception message e.g. 'Product not unique.'
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.SingleOrDefaultWithClearException``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            A regular SingleOrDefault() will give you an exception if there are multiple elements in the collection.
            But not a very clear exception, like 'The input sequence contains more than one element.'
            SingleOrDefaultWithClearException() will allow you to do a SingleOrDefault,
            but get a clearer exception message e.g. 'Product with key { productNumber = 123 } not unique.'
            Only really works if you filtered by something.
            </summary>
            <param name="keyIndicator">
            Not used for filtering, only used in the exception message.
            You can use an anonymous type e.g. new { id, cultureName } and it will translate that to something like { id = 1234,
            cultureName = nl-NL }.
            </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.SingleOrDefaultWithClearException``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            A regular SingleOrDefault() will give you an exception if there are multiple elements in the collection.
            But not a very clear exception, like 'The input sequence contains more than one element.'
            SingleOrDefaultWithClearException() will allow you to do a SingleOrDefault,
            but get a clearer exception message e.g. 'Product with key { productNumber = 123 } not unique.'
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.SingleOrDefaultWithClearException``1(System.Collections.Generic.IEnumerable{``0},System.Object)">
            <summary>
            A regular SingleOrDefault() will give you an exception if there are multiple elements in the collection.
            But not a very clear exception, like 'The input sequence contains more than one element.'
            SingleOrDefaultWithClearException() will allow you to do a SingleOrDefault,
            but get a clearer exception message e.g. 'Product with key { productNumber = 123 } not unique.'
            Only really works if you filtered by something.
            </summary>
            <param name="keyIndicator">
            Not used for filtering, only used in the exception message.
            You can use an anonymous type e.g. new { id, cultureName } and it will translate that to something like { id = 1234,
            cultureName = nl-NL }.
            </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.SingleOrDefaultWithClearException``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Object)">
            <summary>
            A regular SingleOrDefault() will give you an exception if there are multiple elements in the collection.
            But not a very clear exception, like 'The input sequence contains more than one element.'
            SingleOrDefaultWithClearException() will allow you to do a SingleOrDefault,
            but get a clearer exception message e.g. 'Product with key { productNumber = 123 } not unique.'
            Only really works if you filtered by something.
            </summary>
            <param name="keyIndicator">
            Not used for filtering, only used in the exception message.
            You can use an anonymous type e.g. new { id, cultureName } and it will translate that to something like { id = 1234,
            cultureName = nl-NL }.
            </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.SingleWithClearException``1(System.Collections.Generic.IEnumerable{``0},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            A regular Single() will give you an exception if there are no elements or multiple elements in the collection.
            But not a very clear exception, like 'The input sequence contains more than one element.'
            SingleWithClearException() will allow you to do a Single,
            but get a clearer exception message e.g. 'Product with key { productNumber = 123 } not unique.'
            Only really works if you filtered by something.
            </summary>
            <param name="keyIndicator">
            Not used for filtering, only used in the exception message.
            You can use an anonymous type e.g. new { id, cultureName } and it will translate that to something like { id = 1234,
            cultureName = nl-NL }.
            </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.SingleWithClearException``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            A regular Single() will give you an exception if there are no elements or multiple elements in the collection.
            But not a very clear exception, like 'The input sequence contains more than one element.'
            SingleWithClearException() will allow you to do a Single,
            but get a clearer exception message e.g. 'Product with key { productNumber = 123 } not unique.'
            Only really works if you filtered by something.
            </summary>
            <param name="keyIndicator">
            Not used for filtering, only used in the exception message.
            You can use an anonymous type e.g. new { id, cultureName } and it will translate that to something like { id = 1234,
            cultureName = nl-NL }.
            </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.SingleWithClearException``1(System.Collections.Generic.IEnumerable{``0},System.Object)">
            <summary>
            A regular Single() will give you an exception if there are no elements or multiple elements in the collection.
            But not a very clear exception, like 'The input sequence contains more than one element.'
            SingleWithClearException() will allow you to do a Single,
            but get a clearer exception message e.g. 'Product with key { productNumber = 123 } not unique.'
            Only really works if you filtered by something.
            </summary>
            <param name="keyIndicator">
            Not used for filtering, only used in the exception message.
            You can use an anonymous type e.g. new { id, cultureName } and it will translate that to something like { id = 1234,
            cultureName = nl-NL }.
            </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.SingleWithClearException``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            A regular Single() will give you an exception if there are no elements or multiple elements in the collection.
            But not a very clear exception, like 'The input sequence contains more than one element.'
            SingleWithClearException() will allow you to do a Single,
            but get a clearer exception message e.g. 'Product not unique.'
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.SingleWithClearException``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Object)">
            <summary>
            A regular Single() will give you an exception if there are no elements or multiple elements in the collection.
            But not a very clear exception, like 'The input sequence contains more than one element.'
            SingleWithClearException() will allow you to do a Single,
            but get a clearer exception message e.g. 'Product with key { productNumber = 123 } not unique.'
            Only really works if you filtered by something.
            </summary>
            <param name="keyIndicator">
            Not used for filtering, only used in the exception message.
            You can use an anonymous type e.g. new { id, cultureName } and it will translate that to something like { id = 1234,
            cultureName = nl-NL }.
            </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.SingleWithClearException``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            A regular Single() will give you an exception if there are no elements or multiple elements in the collection.
            But not a very clear exception, like 'The input sequence contains more than one element.'
            SingleWithClearException() will allow you to do a Single,
            but get a clearer exception message e.g. 'Product not unique.'
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.ToHashSet``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Yes, you could write "new HashSet(someCollection)".
            But there are already the ToArray() and ToList() methods, so why not a ToHashSet() method to make it consistent?
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.ToNonUniqueDictionary``2(System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0})">
            <summary>
            Similar to ToDictionary, but allows the same key to be present more than once.
            A GroupBy can overcome that limitation too, but sometimes it is nice to have the return value be a Dictionary,
            which might make for a faster lookup too.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.ToNonUniqueDictionary``2(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{``0,``1}})">
            <summary>
            GroupBy might allow grouping by a non-unique key, but converting it to a Dictionary might make for a faster
            lookup.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.ToNonUniqueDictionary``3(System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0},System.Func{``1,``2})">
            <summary>
            Similar to ToDictionary, but allows the same key to be present more than once.
            A GroupBy can overcome that limitation too, but sometimes it is nice to have the return value be a Dictionary,
            which might make for a faster lookup too.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.TrimAll(System.Collections.Generic.IEnumerable{System.String},System.Char[])">
            <summary> Trims all the strings in the collection. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.TryGetIndexOf``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the list index of the first item that matches the predicate.
            Does not check duplicates, because that would make it slower.
            This method prefixed with 'TryGet' returns null if the item is not found.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.TryGetIndexOf``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            IList&lt;T&gt; has an IndexOf method natively. This overload provides one for IEnumerable&lt;T&gt;,
            for both syntactic sugar and it prevents full materialization of the collection.
            This method prefixed with 'TryGet' returns null if the item is not found.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.TryGetIndexOf``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the list index of the first item that matches the predicate.
            Does not check duplicates, because that would make it slower.
            This method prefixed with 'TryGet' returns null if the item is not found.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.TryRemoveFirst``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean})">
            <summary>
            Removes the first occurrence that matches the predicate.
            Does nothing if no item matches the predicate.
            Does not check duplicates, which makes it faster if you are sure only one item is in it.
            Returns whether an item was actually removed from the collection.
            Example: myCollection.TryRemoveFirst(x => x.ID == 3);
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Union``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary> Overload of Union that takes a single item, e.g. myCollection.Union(myItem); </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Union``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary> Overload of Union that takes a comma separated argument list, e.g. myCollection.Union(4, 7, 12); </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Union``1(``0,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Overload of Union that takes starts with a single item and then adds a collection to it e.g.
            myItem.Union(myCollection);
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Action{``0,``1})">
            <summary>
            Overload of Zip when you do not want to produce a result,
            you just want to process two collections side by side in another way.
            </summary>
            <see cref="M:System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})" />
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary> Overload of Zip without a result selector that returns tuples. </summary>
            <see cref="M:System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})" />
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Collections.Generic.IEnumerable{System.Decimal},System.Decimal)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Decimal[],System.Decimal)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Collections.Generic.IEnumerable{System.Decimal},System.Int32,System.Decimal,System.Decimal,System.Decimal)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Decimal[],System.Int32,System.Decimal,System.Decimal,System.Decimal)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Collections.Generic.IEnumerable{System.Double},System.Double)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Double[],System.Double)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Collections.Generic.IEnumerable{System.Double},System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Double[],System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Collections.Generic.IEnumerable{System.Int16},System.Int16)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Int16[],System.Int16)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Collections.Generic.IEnumerable{System.Int16},System.Int32,System.Int16,System.Int16,System.Int16)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Int16[],System.Int32,System.Int16,System.Int16,System.Int16)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Collections.Generic.IEnumerable{System.Int32},System.Int32)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Int32[],System.Int32)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Collections.Generic.IEnumerable{System.Int32},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Collections.Generic.IEnumerable{System.Int64},System.Int64)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Int64[],System.Int64)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Collections.Generic.IEnumerable{System.Int64},System.Int32,System.Int64,System.Int64,System.Int64)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Int64[],System.Int32,System.Int64,System.Int64,System.Int64)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Collections.Generic.IEnumerable{System.Single},System.Single)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Single[],System.Single)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Collections.Generic.IEnumerable{System.Single},System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_BinarySearchInexact.BinarySearchInexact(System.Single[],System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Searches a sorted collection in an efficient way.
            Returns the value before and the value after
            if a value to search is in between two values in the list.
            Will only return a meaningful result if the collection is sorted.
            </summary>
            <param name="sortedCollection"> Not checked for null, for performance. </param>
        </member>
        <member name="T:JJ.Framework.Collections.CollectionExtensions_Recursive_IList">
            <summary>
            Should be slightly faster than the extensions that take IEnumerable.
            </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_Recursive_IList.SelectRecursive``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Collections.Generic.IList{``0}})">
            <summary> Does not include the collection it is executed upon in the result. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_Recursive_IList.SelectRecursive``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Collections.Generic.IList{``0}},System.Collections.Generic.HashSet{``0})">
            <summary> Does not include the collection it is executed upon in the result. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_Recursive_IList.SelectRecursive``1(``0,System.Func{``0,System.Collections.Generic.IList{``0}})">
            <summary> Does not include the item it is executed upon in the result. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_Recursive_IList.SelectRecursive``1(``0,System.Func{``0,System.Collections.Generic.IList{``0}},System.Collections.Generic.HashSet{``0})">
            <summary> Does not include the item it is executed upon in the result. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_Recursive_IList.UnionRecursive``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Collections.Generic.IList{``0}})">
            <summary> Includes the collection it is executed upon in the result. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_Recursive_IList.UnionRecursive``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Collections.Generic.IList{``0}},System.Collections.Generic.HashSet{``0})">
            <summary> Includes the collection it is executed upon in the result. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_Recursive_IList.UnionRecursive``1(``0,System.Func{``0,System.Collections.Generic.IList{``0}})">
            <summary> Includes the item it is executed upon in the result. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_Recursive_IList.UnionRecursive``1(``0,System.Func{``0,System.Collections.Generic.IList{``0}},System.Collections.Generic.HashSet{``0})">
            <summary> Includes the item it is executed upon in the result. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_Recursive_IEnumerable.SelectRecursive``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary> Does not include the collection it is executed upon in the result. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_Recursive_IEnumerable.SelectRecursive``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``0}},System.Collections.Generic.HashSet{``0})">
            <summary> Does not include the collection it is executed upon in the result. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_Recursive_IEnumerable.SelectRecursive``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary> Does not include the item it is executed upon in the result. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_Recursive_IEnumerable.SelectRecursive``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}},System.Collections.Generic.HashSet{``0})">
            <summary> Does not include the item it is executed upon in the result. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_Recursive_IEnumerable.UnionRecursive``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary> Includes the collection it is executed upon in the result. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_Recursive_IEnumerable.UnionRecursive``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``0}},System.Collections.Generic.HashSet{``0})">
            <summary> Includes the collection it is executed upon in the result. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_Recursive_IEnumerable.UnionRecursive``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary> Includes the item it is executed upon in the result. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionExtensions_Recursive_IEnumerable.UnionRecursive``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}},System.Collections.Generic.HashSet{``0})">
            <summary> Includes the item it is executed upon in the result. </summary>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Decimal[],System.Decimal)">
            <summary> Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted. </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Decimal[],System.Decimal,System.Decimal@,System.Decimal@)">
            <summary> Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted. </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Decimal[],System.Int32,System.Decimal,System.Decimal,System.Decimal)">
            <summary>
            Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted.
            Overload with more values you supply yourself: halfLength, min and max, that you could cache yourself for performance.
            </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Decimal[],System.Int32,System.Decimal,System.Decimal,System.Decimal,System.Decimal@,System.Decimal@)">
            <summary>
            Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted.
            Overload with more values you supply yourself: halfLength, min and max, that you could cache yourself for performance.
            </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Double[],System.Double)">
            <summary> Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted. </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Double[],System.Double,System.Double@,System.Double@)">
            <summary> Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted. </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Double[],System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted.
            Overload with more values you supply yourself: halfLength, min and max, that you could cache yourself for performance.
            </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Double[],System.Int32,System.Double,System.Double,System.Double,System.Double@,System.Double@)">
            <summary>
            Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted.
            Overload with more values you supply yourself: halfLength, min and max, that you could cache yourself for performance.
            </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Int16[],System.Int16)">
            <summary> Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted. </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Int16[],System.Int16,System.Int16@,System.Int16@)">
            <summary> Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted. </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Int16[],System.Int32,System.Int16,System.Int16,System.Int16)">
            <summary>
            Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted.
            Overload with more values you supply yourself: halfLength, min and max, that you could cache yourself for performance.
            </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Int16[],System.Int32,System.Int16,System.Int16,System.Int16,System.Int16@,System.Int16@)">
            <summary>
            Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted.
            Overload with more values you supply yourself: halfLength, min and max, that you could cache yourself for performance.
            </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Int32[],System.Int32)">
            <summary> Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted. </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Int32[],System.Int32,System.Int32@,System.Int32@)">
            <summary> Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted. </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted.
            Overload with more values you supply yourself: halfLength, min and max, that you could cache yourself for performance.
            </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted.
            Overload with more values you supply yourself: halfLength, min and max, that you could cache yourself for performance.
            </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Int64[],System.Int64)">
            <summary> Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted. </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Int64[],System.Int64,System.Int64@,System.Int64@)">
            <summary> Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted. </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Int64[],System.Int32,System.Int64,System.Int64,System.Int64)">
            <summary>
            Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted.
            Overload with more values you supply yourself: halfLength, min and max, that you could cache yourself for performance.
            </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Int64[],System.Int32,System.Int64,System.Int64,System.Int64,System.Int64@,System.Int64@)">
            <summary>
            Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted.
            Overload with more values you supply yourself: halfLength, min and max, that you could cache yourself for performance.
            </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Single[],System.Single)">
            <summary> Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted. </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Single[],System.Single,System.Single@,System.Single@)">
            <summary> Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted. </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Single[],System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted.
            Overload with more values you supply yourself: halfLength, min and max, that you could cache yourself for performance.
            </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="M:JJ.Framework.Collections.CollectionHelper.BinarySearchInexact(System.Single[],System.Int32,System.Single,System.Single,System.Single,System.Single@,System.Single@)">
            <summary>
            Searches a sorted collection in an efficient way. Returns the value before and the value after, if a value to search is in between two values in the list. Will only return a meaningful result if the collection is sorted.
            Overload with more values you supply yourself: halfLength, min and max, that you could cache yourself for performance.
            </summary>
            <param name="sortedArray"> Not checked for null, for performance. </param>
        </member>
        <member name="T:JJ.Framework.Collections.RedBlackTree`2">
            <summary>
            Provides insert, delete and lookup operators that all have complexity O(log n).
            It can also at any time return the maximum and minimum with the same performance.
            It will prevent duplicates from being added (duplicates are ignored).
            You can use key-value pairs, instead of just single values.
            </summary>
        </member>
    </members>
</doc>
