<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JJ.Framework.Xml</name>
    </assembly>
    <members>
        <member name="M:JJ.Framework.Xml.XmlHelper.SelectNode(System.Xml.XmlNode,System.String)">
            <summary>
            Gets the node that matches the XPath.
            If the node is not unique or not found, an exception is thrown with a descriptive error message.
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlHelper.TrySelectNode(System.Xml.XmlNode,System.String)">
            <summary>
            Tries to get the node that matches the XPath.
            If the node is not unique, an exception is thrown with a descriptive error message.
            Null is returned if the node is not found.
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlHelper.GetElement(System.Xml.XmlElement,System.String)">
            <summary>
            Gets a child element with a given name.
            If the element is not unique or not found, an exception is thrown with a descriptive error message.
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlHelper.TryGetElement(System.Xml.XmlElement,System.String)">
            <summary>
            Tries to get a child element with a given name.
            Null is returned if the element is not found.
            If the element is not unique, an exception is thrown.
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlHelper.GetElements(System.Xml.XmlElement,System.String)">
            <summary>
            Gets the child elements with a given name.
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlHelper.GetAttribute(System.Xml.XmlElement,System.String)">
            <summary>
            Gets an attribute with a given name.
            If the attribute is not found, an exception is thrown with a descriptive error message.
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlHelper.TryGetAttribute(System.Xml.XmlElement,System.String)">
            <summary>
            Tries to get an attribute with a given name.
            Null is returned if the attribute is not found.
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlHelper.GetAttributeValue(System.Xml.XmlElement,System.String)">
            <summary>
            Gets the value of an attribute with a given name.
            If the attribute is not found or the value is left empty,
            an exception is thrown with a descriptive error message.
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlHelper.TryGetAttributeValue(System.Xml.XmlElement,System.String)">
            <summary>
            Tries to get the value of an attribute with a given name.
            Null or empty string is returned if the attribute is not present or no value is filled in.
            </summary>
        </member>
        <member name="T:JJ.Framework.Xml.XmlToObjectConverter`1">
            <summary>
            Converts an XML structure to an object tree.
            
            (Under certain platforms standard XML serialization may not be available 
            or may not be the best option. That is why this class exists.)
            
            By default properties are mapped to XML elements.
            
            To map to XML attributes, mark a property with the XmlAttribute attribute.
            
            If a property is an Array type or a supported collection type, 
            a parent XML element is expected,
            and a child element for each position in the array.
            That single collection property maps to both this parent element and the child elements.
            The supported collection types are Array types, List&lt;T&gt;, IList&lt;T&gt;, ICollection&lt;T&gt; and IEnumerable&lt;T&gt;.
            
            By default the names in the XML are the camel-case version of the property names.
            For XML array items, however, it is not the property name, but the collection property's item type name converted to camel case.
            To diverge from this standard, you can specify the node name explicitly by using the following .NET attributes
            on the properties: XmlElement, XmlAttribute, XmlArray and XmlArrayItem.
            
            Reference types are always optional. Value types are optional only if they are nullable.
            Collection types are always optional. If only the parent element is present, an empty collection will be assigned.
            If the parent element is missing from the XML, the collection will be null.
            
            Recognized values are the .NET primitive types: Boolean, Char, Byte, IntPtr, UIntPtr
            the numeric types, their signed and unsigned variations and
            String, Guid, DateTime, TimeSpan and Enum types.
            
            The composite types in the object structure must have parameterless constructors.
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.ConvertProperties(System.Xml.XmlElement,System.Object)">
            <summary>
            Goes through all the properties of the parent object, tries to look up
            the corresponding child nodes out of the parent node and reads out values from them
            to fill in the properties.
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.ConvertProperty(System.Xml.XmlElement,System.Object,System.Reflection.PropertyInfo)">
            <summary>
            Converts a child node of a parent element to a property of an object.
            A child node is selected based on the property name.
            First it is determined which type of node it is: an element, XML attribute or XML array.
            This is based on the property type and the .NET attributes that the property is annotated with.
            
            If the property is a composite type, recursive calls are made to fill the rest of the structure.
            This also counts if an XML array has items of a composite type.
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.DetermineNodeType(System.Reflection.PropertyInfo)">
            <summary>
            Examines the type and attributes of property 
            to determine what type of XML node is expected for it 
            (element, attribute or array).
            Also verifies that a property is not marked with conflicting attributes.
            
            By default a property maps to an element.
            You can optionally mark it with the XmlElement attribute to make that extra clear.
            
            To map to an XML attribute, mark the property with the XmlAttribute attribute.
            
            To map to an array, the property must be of an Array type,
            and the XML needs both a parent element that represents the array,
            and child elements that represent the array items.
            
            If a property is an array type, it cannot be marked with the XmlAttribute or XmlElement attributes.
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.ConvertElementFromParent(System.Xml.XmlElement,System.Object,System.Reflection.PropertyInfo)">
            <summary>
            Gets a child element from the parent element and converts it to a property of an object.
            Recursive calls might be made. Nullability is checked.
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.ConvertElement(System.Xml.XmlElement,System.Object,System.Reflection.PropertyInfo)">
            <summary>
            Converts an element to the object's property value.
            For values this means a property's value is assigned.
            For composite types this means that a new object is created,
            and a recursive call to ConvertProperties is made to convert each property of the composite type.
            sourceElement is not nullable.
            </summary>
            <param name="sourceElement">not nullable</param>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.ConvertElement(System.Xml.XmlElement,System.Type)">
            <summary>
            Converts an element to a value or composite type.
            For loose values this means the text is converted to a specific type.
            For composite types this means that a new object is created,
            and a recursive call to ConvertProperties is made to convert each property of the composite type.
            sourceElement is not nullable.
            </summary>
            <param name="sourceElement">not nullable</param>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.ConvertLeafElement(System.Xml.XmlElement,System.Type)">
            <summary>
            Converts the element's value to a specific type.
            sourceElement is not nullable.
            </summary>
            <param name="sourceElement">not nullable</param>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.ConvertCompositeElement(System.Xml.XmlElement,System.Type)">
            <summary>
            Creates a new object and does a recursive call to ConvertProperties
            to convert each of the composite type's properties.
            sourceElement is not nullable.
            </summary>
            <param name="sourceElement">not nullable</param>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.GetElementNameForProperty(System.Reflection.PropertyInfo)">
            <summary>
            Gets the XML element name for a property.
            By default this is the property name converted to camel case 
            e.g. MyProperty -&gt; myProperty.
            You can also specify the expected XML element name explicitly
            by marking the property with the XmlElement attribute and specifying the
            name with it e.g. [XmlElement("myElement")].
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.TryGetXmlElementNameFromAttribute(System.Reflection.PropertyInfo)">
            <summary>
            Tries to get an XML element name from the XmlElement attribute that the property is marked with,
            e.g. [XmlElement("myElement")]. If no name is specified there, returns null or empty string.
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.ConvertAttributeFromParent(System.Xml.XmlElement,System.Object,System.Reflection.PropertyInfo)">
            <summary>
            Gets an attribute from the given element and converts it to a property of an object.
            
            Nullability is checked.
            If it is a nullable type or a reference type, an XML attribute can be omitted or its value left blank.
            Otherwise, the omission of the attribute causes an exception.
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.ConvertAttribute(System.Xml.XmlAttribute,System.Type)">
            <summary>
            Converts an XML attribute to a value of a specific type.
            Will return null if the attribute does not exist or if its value is blank.
            </summary>
            <param name="sourceXmlAttribute">nullable</param>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.GetAttributeNameForProperty(System.Reflection.PropertyInfo)">
            <summary>
            Gets the XML attribute name for a property.
            By default this is the property name converted to camel case 
            e.g. MyProperty -&gt; myProperty.
            You can also specify the expected XML element name explicitly,
            by marking the property with the XmlAttribute attribute and specifying the
            name with it e.g. [XmlAttribute("myAttribute")].
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.TryGetAttributeNameFromAttribute(System.Reflection.PropertyInfo)">
            <summary>
            Get the XML attribute name from the XmlAttribute attribute that the property is marked with,
            e.g. [XmlAttribute("myAttribute")]. If no name is specified there, returns null or empty string.
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.IsSupportedCollectionType(System.Type)">
            <summary>
            Returns whether the type should be handled as an XML Array.
            This means whether it is Array or List&lt;T&gt;-assignable.
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.ConvertXmlArrayFromParent(System.Xml.XmlElement,System.Object,System.Reflection.PropertyInfo)">
             <summary>
             Converts an XML array: an XML element that represents the whole array with a child element for each position in the array.
             It is a converted to a collection property that is an Array, List&lt;T&gt;, IList&lt;T&gt;, ICollection&lt;T&gt; or IEnumerable&lt;T&gt;.
            
             A collection property is always nullable.
             For an array a new array is assigned and to any of the other supported collection types a List&lt;T&gt; is assigned.
             
             The collection items can be loose values or composite types.
             For composite types a new object will be created,
             and a recursive call to ConvertProperties is made to convert each property of the composite type.
             </summary>
             <param name="sourceParentElement">The parent of the XML Array element.</param>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.ConvertXmlArrayItems(System.Collections.Generic.IList{System.Xml.XmlElement},System.Object,System.Reflection.PropertyInfo)">
             <summary>
             Converts XML array items.
             They are converted to a collection property that is an Array, List&lt;T&gt;, IList&lt;T&gt;, ICollection&lt;T&gt; or IEnumerable&lt;T&gt;.
            
             The collection property is always nullable.
             For an array a new array is assigned and to any of the other supported collection types a List&lt;T&gt; is assigned.
             
             The collection items can be loose values or composite types.
             For composite types a new object will be created,
             and a recursive call to ConvertProperties is made to convert each property of the composite type.
             </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.ConvertXmlArrayItemsToArray(System.Collections.Generic.IList{System.Xml.XmlElement},System.Type)">
             <summary>
             Converts XML array items to an instance of an Array type.
            
             The array items can be loose values or composite types.
             For composite types a new object will be created,
             and a recursive call to ConvertProperties is made to convert each property of the composite type.
             </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.ConvertXmlArrayItemsToList(System.Collections.Generic.IList{System.Xml.XmlElement},System.Type)">
             <summary>
             Converts XML array items to List&lt;T&gt;.
            
             The collection items can be loose values or composite types.
             For composite types a new object will be created,
             and a recursive call to ConvertProperties is made to convert each property of the composite type.
             </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.TryGetSourceArrayXmlElement(System.Xml.XmlElement,System.Reflection.PropertyInfo)">
            <summary>
            Tries to get an XML array from a parent XML element.
            An XML array is an XML element representing the whole array,
            with a child element for each position in the array.
            
            destCollectionProperty is used to get the expected XML array element name.
            By default this is the property name converted to camel case 
            e.g. MyCollection -&gt; myCollection.
            You can also specify the expected XML element name explicitly,
            by marking the property with the XmlArray attribute and specifying the
            name with it e.g. [XmlArray("myCollection")].
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.GetSourceXmlArrayItems(System.Xml.XmlElement,System.Reflection.PropertyInfo)">
            <summary>
            Gets the array item XML elements from the given array XML element.
            destCollectionProperty is used to get the expected XML array item element name.
            destCollectionProperty must specify the XmlArrayItem attribute 
            to indicate what the name of the array item XML elements should be.
            </summary>
            <param name="destCollectionProperty">Is used to get the expected XML array item element name.</param>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.GetXmlArrayNameForCollectionProperty(System.Reflection.PropertyInfo)">
            <summary>
            Gets the Array XML element name for a collection property.
            By default this is the property name converted to camel case 
            e.g. MyCollection -&gt; myCollection.
            You can also specify the expected XML element name explicitly,
            by marking the property with the XmlArray attribute and specifying the
            name with it e.g. [XmlArray("myCollection")].
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.TryGetXmlArrayNameFromAttribute(System.Reflection.PropertyInfo)">
            <summary>
            Gets an Array XML element name from the XmlArray attribute that the property is marked with,
            e.g. [XmlArray("myArray")]. If no name is specified, null or empty string is returned.
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.GetXmlArrayItemNameForCollectionProperty(System.Reflection.PropertyInfo)">
            <summary>
            Gets the XML element name for an array item for the given collection property.
            By default this is the collection property's item type name converted to camel case e.g. MyElementType -&gt; myElementType.
            You can also specify the expected XML element name explicitly,
            by marking the collection property with the XmlArrayItem attribute and specifying the
            name with it e.g. [XmlArrayItem("myElementType")].
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.TryGetXmlArrayItemNameFromAttribute(System.Reflection.PropertyInfo)">
            <summary>
            Gets an XML element name from the XmlArrayItem attribute that the property is marked with.
            e.g. [XmlArrayItem("myItem")]. If no name is specified, null or empty string is returned.
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.IsNullable(System.Type)">
            <summary>
            Returns whether the type is considered nullable in general.
            Concretely this means any reference type and any Nullable&lt;T&gt;.
            </summary>
        </member>
        <member name="M:JJ.Framework.Xml.XmlToObjectConverter`1.IsSupportedGenericCollectionType(System.Type)">
            <summary>
            Returns whether a generic collection type is supported.
            The supported types are List&lt;T&gt;, IList&lt;T&gt;, ICollection&lt;T&gt; and IEnumerable&lt;T&gt;.
            </summary>
        </member>
    </members>
</doc>
